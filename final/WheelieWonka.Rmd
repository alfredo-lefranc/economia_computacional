---
output:
  pdf_document: null
  geometry: margin=1in
  html_document:
    df_print: paged
fontsize: 11pt
header-includes: \usepackage{geometry} \usepackage{graphicx} \tolerance=1 \hyphenpenalty=10000
  \hbadness=10000 \linespread{1.2} \usepackage[justification=centering, font=bf, labelsep=period,
  skip=5pt]{caption}
  \usepackage{babel} \usepackage{fancyhdr}
  \pagestyle{fancy} \fancyhead[L]{Maestría en Economía Aplicada} \fancyhead[R]{ITAM}
---
\begin{titlepage}
\begin{center}

\textsc{\Large Instituto Tecnológico Autónomo de México}\\[2em]

\textbf{\LARGE Economía Computacional}\\[2em]


\textsc{\LARGE }\\[1em]


\textsc{\LARGE Trabajo Final }\\[1em]
\textsc{\large }\\[1em]
\textsc{\LARGE Equipo 7 }\\[1em]

\textsc{\large }\\[1em]

\textsc{\LARGE Prof. Isidoro García Urquieta}\\[1em]

\textsc{\LARGE }\\[1em]
\textsc{\LARGE }\\[1em]

\textsc{\LARGE Alfredo Lefranc Flores}\\[1em]

\textsc{\large 144346}\\[1em]

\textsc{\LARGE Cynthia Raquel Valdivia Tirado }\\[1em]

\textsc{\large 81358}\\[1em]

\textsc{\LARGE Rafael Sandoval Fernández}\\[1em]

\textsc{\large 143689}\\[1em]

\textsc{\LARGE Marco Antonio Ramos Juárez}\\[1em]

\textsc{\large 142244}\\[1em]

\textsc{\LARGE Francisco Velazquez Guadarrama}\\[1em]

\textsc{\large 175606}\\[1em]

\end{center}

\vspace*{\fill}
\textsc{Ciudad de México \hspace*{\fill} 2021}

\end{titlepage}


\newpage


\tableofcontents

\newpage

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, message = FALSE, warning=FALSE,
                      fig.width = 7, fig.height = 4, fig.align = "right",tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

```{r, include=FALSE}

packages <- c(
  "tidyverse", "data.table", "broom", 
  "knitr", "naniar", "lubridate",
  "RCT", "splitstackshape", "magrittr",
  "kableExtra", "GGally", "stargazer",
  "gridExtra", "igraph", "tidygraph",
  "ggraph","networkD3","visNetwork", 
  "reshape2", "ggthemes", "grid"
  )

# instala los paquetes que no se tengan
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# cargar paquetes
lapply(packages,
       library,
       character.only = TRUE)

# desactiva notación científica       
options(scipen = 999)


```

## Planteamiento del Problema

#### Nota: Los títulos indican el objetivo del párrafo, estos son para nosotros. Hay que quitarlos antes de la entrega final.

(Contextualizar)
Al conectar una multiplicidad de orígenes y destinos, el transporte público ha probado ser un motor del desarrollo económico urbano, además de potencialmente impactar los ámbitos de salud y seguridad pública, congestión vehicular, y la inclusión social. En este contexto, los sistemas de bicicletas compartidas han ofrecido una alternativa a las opciones de transporte en redes urbanas altamente complejas.

(Objetivos del negocio)
Como tal, cualquier empresa de bicicletas compartidas debe ser capaz de ofrecer a sus usuarios una opción para trasladarse eficaz, es decir, práctica y accesible. Wheelie Wonka no es la excepción.


(Evaluación de la situación actual)
Tal como es el caso de los flujos de tráfico, las bicicletas enfrentan el problema de demandas asimétricas en tiempo y espacio. Esto puede significar un problema en la medida en que la infraestructura de la red de bicicletas limite a los usuarios en momentos de alta demanda, y también que el uso y desplazamiento de las bicicletas en un momento dado no corresponda a las necesidades de los usuarios siguientes, creando excesos de oferta y de demanda en distintas zonas de Boston.


(Objetivos del proyecto de datos. Ojo, no son iguales a los objetivos del negocio)
En este contexto, la ciencia de datos ofrece una solución muy atractiva. Mediante el análisis computacional del uso de las bicicletas, es posible reconocer patrones y predecir la disponibilidad de bicicletas en un lugar y momento específicos. Esto puede ayudar a Wheelie Wonka en dos sentidos.

1) Proveer al usuario de información con la cual pueda tomar decisiones óptimas de transporte.
2) Poder hacer ajustes en la distribución de las bicicletas a lo largo de las cicloestaciones para prevenir escaseces y excesos en el sistema.

Estos puntos seguramente aumentarían la satisfacción del usuario y permitirían un mayor uso del servicio, lo cual sólo podría traer beneficios a Wheelie Wonka.

En este sentido, los objetivos específicos de este proyecto son los siguientes:

a. Poder pronosticar la duración de los viajes
b. Entender los factores que tienen un impacto en la duración de los viajes. Identificar patrones geográficos en los datos.
c. Estimar el número de bicicletas por estación en ventanas de 10 minutos.

(Estructura del proyecto de datos)


(Establecer medidas de éxito del proyecto de datos)


## Datos

Cargamos los datos
```{r, include=FALSE}
trips <- read.csv("hubway_trips.csv", header = TRUE)
stations <- read.csv("hubway_stations.csv", header = TRUE)
weather <- read.csv("weather.csv", header = TRUE)
```

Buscamos NAs en las variables para poder tomar decisiones al respecto.

````{r}

# asignar NAs a valores vacíos de measurement_flag
weather$Measurement_Flag[weather$Measurement_Flag==" "] <- NA

# función para NAs
check_nas <- function(df){
  df %>% 
    select_if(~sum(is.na(.)) > 0) %>%
    miss_var_summary()
}

# tabla resumen de missing values: trips
kable(check_nas(trips), booktabs=T, align = 'c',
      col.names = c("Variable", "Cantidad","%"), digits = 4, caption = "trips") %>%
  kable_styling(position = "center", latex_options="HOLD_position")

# tabla resumen de missing values: weather
kable(check_nas(weather), booktabs=T, align = 'c',
      col.names = c("Variable", "Cantidad","%"), digits = 4, caption = "weather") %>%
  kable_styling(position = "center", latex_options="HOLD_position")

````

```{r}
# Análisis para imputación de estaciones
prcnt_sameStation <- trunc(sum(trips$strt_statn == trips$end_statn, 
                               na.rm = T) / nrow(trips) * 100 * 100)/100
NA_either <- sum(is.na(trips$strt_statn) | is.na(trips$end_statn))
```

Se decide eliminar la variable "Quality_Flag", pues esta contiene únicamente NAs. 

Además, analizando las observaciones con NA en "strt_statn" o "end_statn", notamos que estas sí tienen valores para variables importantes como "duration", y que no necesariamente coinciden en tener NA para ambas variables, por lo que sí podrían ser útiles si se les imputara algún valor. Lo más directo sería imputarle a la variable con NA el valor de la variable que sí tiene información. Sin embargo, notamos que tan solo el `prcnt_sameStation`% de las observaciones siguen este comportamiento. Dado que para poder predecir la disponibilidad de bicicletas por estación las variables de "strt_statn" o "end_statn" serán muy importantes, se decide simplemente eliminar las observaciones con NA en cualquiera de estas dos variables. Dado que son únicamente `NA_either` las observaciones que cumplen con esta última característica, el efecto eliminarlas es prácticamente nulo.

```{r}
weather$Quality_Flag <- NULL
#weather$Measurement_Flag <- NULL
trips <- trips[!is.na(trips$strt_statn) & !is.na(trips$end_statn), ]
```

Nótese que la información contenida en "birth_date" no es directamente útil, pues se tienen observaciones de distintos años. La información que seguramente será muy relevante es la edad del usuario cuando hizo uso del servicio, no su edad actual. Por ello, para poder analizar la variable "birth_date" y tomar una decisión respecto a sus NA, primero se procesa las variables "start_date", "end_date", y finalmente se genera una variable con la edad a partir de "birth_date". Asimismo, se procesan las fechas en la base del clima para extraer una fecha y hora utilizables. Todo esto con la finalidad de poder realizar un análisis exploratorio que posteriormente permita tomar una decisión.

```{r}
# Se divide start_date en fecha y hora para extraer la información
colnames(trips)[colnames(trips) == 'start_date'] <- 'start_DateTime'
startDateTime <- strsplit(trips$start_DateTime, ' ')

startDate <- sapply(startDateTime, "[", 1)
trips$start_date <- as.Date(startDate, '%m/%d/%Y') %>% date()
trips$start_year <- trips$start_date %>% year()
trips$start_month <- trips$start_date %>% month()
trips$start_weekday <- weekdays(trips$start_date)

startTime <- sapply(startDateTime, "[", 2)
trips$start_hour <- as.POSIXct(startTime,format="%H:%M:%S") %>% 
  hour()
trips$start_minute <- format(as.POSIXct(startTime,format="%H:%M:%S"),"%M")


# Se divide end_date en fecha y hora para extraer la información (poder utilizarla posteriormente)
colnames(trips)[colnames(trips) == 'end_date'] <- 'end_DateTime'
endDateTime <- strsplit(trips$end_DateTime, ' ')

endDate <- sapply(endDateTime, "[", 1)
trips$end_date <- as.Date(endDate, '%m/%d/%Y')
trips$end_year <- format(trips$end_date, '%Y')
trips$end_month <- format(trips$end_date, '%m')
trips$end_weekday <- weekdays(trips$end_date)

endTime <- sapply(endDateTime, "[", 2)
trips$end_hour <- format(as.POSIXct(endTime,format="%H:%M:%S"),"%H")
trips$end_minute <- format(as.POSIXct(endTime,format="%H:%M:%S"),"%M")

# Se genera la edad del usuario al empezar con el servicio
trips$age <- as.integer(trips$start_year) - trips$birth_date

# se hace lo mismo para sacar fecha y hora en la base de clima
weather$start_date <- weather$DATE %>% strsplit(' ') %>% 
  sapply("[", 1) %>% as.Date('%Y%m%d') %>% date()

weather$start_hour <- weather$DATE %>% strsplit(' ') %>% 
  sapply("[", 2) %>% as.POSIXct(format="%H:%M") %>% 
  hour()

# remover objetos grandes
rm(endDateTime,startDateTime,endDate,endTime,startDate,startTime)

```

```{r}
# Para analizar problemas con unir trips y weather
naive_merge <- merge(trips[, c('start_date', 'start_hour')],
                     weather[, c('start_date', 'start_hour', 'HPCP')], 
                     by = c('start_date', 'start_hour'), all.x = T)
HPCP_NAs_prcnt <- trunc(mean(is.na(naive_merge$HPCP))*100*100)/100
rm(naive_merge)
```

Ahora, se procede a unir la base que contiene la información sobre los viajes con las columnas relevantes de las otras bases. Esto se hace primero con la información sobre el clima a la hora que inicia y termina el viaje. Naturalmente, sería ideal tener información sobre el nivel de precipitación registrada durante cada minuto de los viajes de los usuarios. Sin embargo, este no es el caso. En nuestra base principal tenemos `length(unique(trips$start_date))` días para los cuales se registró al menos un viaje, pero únicamente contamos con `length(unique(weather$start_date))` días que sí tienen mediciones. Más aún, si fuésemos a asignar valores a cada viaje para el nivel de precipitación con base en un match estricto con la fecha y hora de la medición, tendríamos que el `HPCP_NAs_prcnt`% de esta nueva columna serían NAs. Consideramos que esta variable podría tener mucha información importante como para eliminarla, y que las mediciones con las que contamos aún pueden decirnos mucho más: cuando llueve, las afectaciones de dicho fenómeno son persistentes temporalmente, pues el hecho de que no se tenga medición para una hora después de un registro, esto no implica que ya no esté lloviendo, o que el clima ha mejorado. Del mismo modo, las calles suelen continuar mojadas una o varias horas después. Por otra parte, cuando llueve, esto no sucede sin previo aviso, de un minuto a otro. Con base en este razonamiento, se decide utilizar las pocas observaciones que sí se tienen para crear un índice alrededor de la hora sobre la cual sí se tien registro de la siguiente manera: para cada día y hora en que se registró un viaje, si existe un registro para el clima este se deja intacto. Cuando no, se utiliza un promedio de la lluvia registrada en el intervalo que comprende desde tres horas antes (efectos persistentes del clima del pasado) y hasta una hora después (previsión del clima futuro dado el presente). Nótese que los registros del nivel de precipitación en esta nueva variable únicamente toman `length(unique(trips$HPCP))-1` valores posibles. Como los NA aún persisten, a estos se les asigna el valor "SR" (Sin Registro), y se trata a toda la variable como un factor por intervalos. 

Usando un razonamiento similar, se considera que, en general, el hecho de que haya llovido durante el día puede también decirnos algo de información relativamente distinta. Por un lado, si había llovido antes de tomar una bicicleta, esto podría tener un efecto en las decisiones de los usuarios a través de sus ánimos y la expectativa del clima para el resto del día. Por otro, si aún no había llovido, es altamente probable que los usuarios hayan elegido iniciar un viaje con base en sus propias predicciones respecto al clima para el resto del día con base en factores que, para efectos de nuestros datos, no son observables. Es por ello que también se crea una variable que nos informa si llovió o no en un determinado día. 


```{r}

# Imputación a los NA para HPCP en la base trips
weather$start_hour <- as.integer(weather$start_hour)
unique_dates <- unique(trips$start_date)
weather_calendar <- as.data.frame(matrix(NA, nrow = length(unique_dates), ncol = 25))
colnames(weather_calendar) <- c('start_date', 0:23)
weather_calendar$start_date <- unique_dates
for ( i in 1:nrow(weather_calendar) ) {
  curr_date <- weather_calendar$start_date[i]
  ss_by_date <- weather[weather$start_date == curr_date, c('start_hour', 'HPCP')]
  if (nrow(ss_by_date) > 0) {
    aux <- 3
    for ( j in 0:22 ) {
      ss_by_hr <- ss_by_date[ss_by_date$start_hour >= (j-3+aux) & ss_by_date$start_hour <= (j+1), 
                             c('start_hour', 'HPCP')]
      est_weather <- sum(ss_by_hr$HPCP, na.rm=T) / 5
      if (nrow(ss_by_hr) > 0) {
        weather_calendar[i, j+2] <- est_weather
      }
      true_weather <- ss_by_date[ss_by_date$start_hour == j, c('start_hour', 'HPCP')]
      if (nrow(true_weather) > 0) {
        weather_calendar[i, j+2] <- max(true_weather$HPCP[1], est_weather)
      }
      aux <- max(aux - 1,0)
    }
    # La hora 23, inalcanzable en el loop anterior
    ss_by_hr <- ss_by_date[ss_by_date$start_hour >= (23-3) & ss_by_date$start_hour <= (23), 
                           c('start_hour', 'HPCP')]
    est_weather <- sum(ss_by_hr$HPCP, na.rm=T) / 5
    if (nrow(ss_by_hr) > 0) {
        weather_calendar[i, 23+2] <- est_weather
    }
    true_weather <- ss_by_date[ss_by_date$start_hour == 23, c('start_hour', 'HPCP')]
    if (nrow(true_weather) > 0) {
      weather_calendar[i, 23+2] <- max(true_weather$HPCP[1], est_weather)
      }
  }
}

date_matcher <- melt(weather_calendar, id.var = 'start_date', variable.name = 'start_hour')
date_matcher$start_hour <- as.integer(date_matcher$start_hour)
colnames(date_matcher)[3] <- 'HPCP'
trips <- merge(trips, date_matcher, by=c("start_date", "start_hour"), all.x=T)

# Creación de la variable indicadora de día lluvioso
rained_matcher <- aggregate(HPCP~start_date, data=weather, FUN=sum, na.action = na.omit)
rained_matcher$rained <- ifelse(rained_matcher$HPCP>0, 1, 0)
trips <- merge(trips, rained_matcher[,c('start_date', 'rained')], by='start_date', all.x=T)

HPCP_NAs_prcnt <- trunc(mean(is.na(trips$HPCP))*100*100)/100 # Porcentaje de NAs en HPCP
rained_NAs_prcnt <- trunc(mean(is.na(trips$rained))*100*100)/100 # Porcentaje de NAs en rained

# Se forman intervalos para el nivel de lluvia
trips$HPCP <- cut(trips$HPCP, 
                  breaks=c(-0.001, seq(0,0.09,.015), seq(0.1,0.25,0.025),0.35,0.5,0.7,1.5), 
                  labels=c(0, seq(0,0.09,.015)[-1], seq(0.1,0.25,0.025),0.35,0.5,0.7,1.5))

# Se asigna SR a las NA para poder trabajar como factor
trips[is.na(trips$rained), 'rained'] <- 'SR'
trips$HPCP = factor(trips$HPCP, levels=c(levels(trips$HPCP), 'SR'))
trips$HPCP[is.na(trips$HPCP)] = 'SR'

# Se transforman a factor
trips$rained <- trips$rained %>% as.factor

```

Con lo anterior, se disminuyó el número de NAs en "HPCP" a `HPCP_NAs_prcnt`, y además tenemos información meteorológica útil para el `1-rained_NAs_prcnt` de las observaciones, que dado el tamaño de la base, es una buena cantidad.

```{r}
# Transformación de variables

# categóricas
trips$subsc_type <- trips$subsc_type %>% as.factor
trips$gender <- trips$gender %>% as.factor
trips$status <- trips$status %>% as.factor
trips$bike_nr <- trips$bike_nr %>% as.factor
trips$zip_code <- trips$zip_code %>% as.factor
trips$Quality_Flag <- trips$Quality_Flag %>% as.factor

trips$start_year <- trips$start_year %>% as.factor
trips$end_year <- trips$end_year %>% as.factor
trips$start_month <- trips$start_month %>% as.factor
trips$end_month <- trips$end_month %>% as.factor
trips$start_weekday <- trips$start_weekday %>% as.factor
trips$end_weekday <- trips$end_weekday %>% as.factor

# numéricas 
trips$start_hour <- trips$start_hour %>% as.integer
trips$end_hour <- trips$end_hour %>% as.integer
trips$start_minute <- trips$start_minute %>% as.integer
trips$end_minute <- trips$end_minute %>% as.integer

summary(trips)

```

## EDA

Una vez construidas las variables temporales, procedemos a hacer el análisis exploratorio de los datos, teniendo en mente que la variable objetivo es la duración de los viajes.

### Análisis univariado

Primero, revisamos la distribución de las variables.

```{r}
# histograma para variables continuas
myhist <- function(yvar){
  ggplot(trips, aes_(x=as.name(yvar)))+
  geom_histogram()+
  ggtitle(paste0(as.name(yvar)))+
  xlab("")+
  ylab("")+ geom_rangeframe()+
  theme_bw()+
  theme(axis.line = element_line(colour = "black"),
        axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
}

hists<- trips %>%
  select(
    duration,
    start_hour,
    age
  ) %>%
  names() %>%
  lapply(myhist)

# grafico las variables
grid.arrange(grobs=hists,ncol=3,
             top=textGrob("Distribución de las variables"))


# barras para las categóricas
# histograma para variables continuas
mybar <- function(yvar){
  ggplot(trips, aes_(x=as.name(yvar)))+
  geom_bar()+
  ggtitle(paste0(as.name(yvar)))+
  xlab("")+
  ylab("")+ geom_rangeframe()+
  theme_bw()+
  theme(axis.line = element_line(colour = "black"),
        axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
}

bars <- trips %>%
  select(
    start_year,
    start_month,
    strt_statn,
    end_statn,
    start_weekday,
    subsc_type,
    gender,
    HPCP,
    Quality_Flag
  ) %>%
names() %>%
lapply(mybar)

# grafico las variables
grid.arrange(grobs=bars,ncol=4,
             top=textGrob("Distribución de las variables"))

```


## Análisis bivariado

```{r}
# Mapa de calor start y end station
x <- trips %>% count(strt_statn, end_statn)
summary(x)

y <- pivot_wider(x, id_cols=c("strt_statn"), 
              names_from=c("end_statn"),
              values_from=c("n"),
              values_fill=0)
class(y)

# Matrix format. nota. las columnas son end stations y las filas start stations
rownames(y) <- y[,1] %>% unlist()
y <- y %>% dplyr::select(c(-1))
y <- as.matrix(y)

library('heatmaply')
heatmaply(y,
          dendrogram = "none",
          colors = c("wheat","navyblue"),
          grid_color = "white",
          fontsize_row = 7, fontsize_col = 7,
          xlab = "",
          ylab = "",
)


```

```{r, cache=TRUE}
# Se muestra la relación entre edad y duración (acotada superiormente por su percentil 99%)
ggplot(trips, aes(age, duration)) +
  geom_point(alpha=0.3) +
  geom_smooth() +
  ylim(0, quantile(trips$duration, probs=0.99))

corr_age_duration <- cor(trips$age, trips$duration, use = "complete.obs")

```

```{r}
# Histograma de la edad para todas las observaciones
ggplot(data=subset(trips, !is.na(age)), aes(x=age)) + 
  geom_histogram() +
  geom_vline(aes(xintercept=mean(age, na.rm=T)), color="black", size=1) +
  geom_vline(aes(xintercept=median(age, na.rm=T)), color="black", linetype="dashed", size=1) 
```

```{r}
# Histograma de la edad por género
ggplot(data=subset(trips, !is.na(age)), aes(x=age, color=gender, fill=gender)) + 
  geom_histogram(alpha=0.2, position="identity") +
  geom_vline(aes(xintercept=mean(age, na.rm=T)), color="orange", size=1) +
  geom_vline(aes(xintercept=median(age, na.rm=T)), color="black", linetype="dashed", size=1) +
  annotate("text",                        # Add text for mean
           x = 25,
           y = 30000,
           label = paste("Median =", median(trips$age, na.rm=T)),
           col = "black",
           size = 4) + 
  annotate("text",                        # Add text for mean
           x = 42,
           y = 30000,
           label = paste("Mean =", trunc(mean(trips$age, na.rm=T)*100)/100),
           col = "orange",
           size = 4)
```


FVG_comentario: falta alguna decisión para imputar/no imputar los NA de "age". Son demasiados, pero no veo que la edad del usuario se relacione mucho con la duración del viaje. La correlación es apenas de `corr_age_duration` (0.002511551). Creo que son demasiadas NA para imputarlas con algún supuesto distribucional. Lo único lógico que veo si queremos usar esa variable es imputarle la media/mediana, o bien crear rangos de edad, asignar 'Unknown' a los NA, y tratarla como factor.

FVG_comentario: también tendremos que decidir cómo tratar valores vacíos de "gender" y de "zip_code" (como el 29.93%). De la tabla de abajo noten cómo los valores vacíos de "gender" corresponden en su totalidad a los usuarios no registrados, y sólo unos pocos adicionales (155) son usuarios registradas pero sin reportar su "zip_code". De momento les imputo unknown, y muestro una tabla con porcentajes de valores vacíos en ambas.

```{r}
empty_gender <- sum(trips$gender=='')
empty_zipcode <- sum(trips$zip_code=='')
unregistered <- sum(trips$subsc_type!='Registered')
aux <- t(cbind(unregistered, empty_gender, empty_zipcode))
aux <- cbind(c('subsc_type','gender','zip_code'), aux, aux)
aux[,3] <- trunc(as.numeric(aux[,2])/nrow(trips)*1000000)/1000000*100
rownames(aux) <- NULL
kable(aux, col.names = c("Variable","Número de valores vacíos", "%"), align = "lrr", booktabs=T) %>%
  kable_styling(position = "center", latex_options="HOLD_position")

# Asigna un valor a los valores vacíos del género y zip_code. 
trips$gender[trips$gender==''] <- 'Unknown' 
trips$zip_code[trips$zip_code==''] <- 'Unknown' 

```

FVG: Eliminamos también `sum(trips$duration < 0)` (49) observaciones que registran una duración negativa, pues es evidente que hubo un error en el registro que vuelve las observaciones inútiles. Al ser un número tan pequeño, esta acción no nos genera preocupación. Asimismo, existen `sum(trips$duration == 0)` (4389) observaciones con una duración de cero, y se decide también eliminarlas, pues podrían representar movimientos accidentales o reacomodos ocasionados por los usuarios y no una salida de una bicicleta. Cabe destacar que sí existen diez observaciones que tienen una duración de cero, pero que registran distintas estaciones en el comienzo y final del viaje. Al ser un número tan pequeño, eliminarlas es nuevamente prácticamente insignificante. 

```{r}

trips <- trips[trips$duration>0, ]

```

Ahora buscamos columnas con el mismo valor para todas las observaciones, pues de ser el caso no serían útiles para el modelo.
  
```{r}

# trips
uselessCols_trips <- c()
for (i in colnames(trips)) {
  if ( length(unique(trips[[i]]))==1 ) {
    uselessCols_trips <- c(uselessCols_trips, i)
  }
}

# stations
uselessCols_stations <- c()
for (i in colnames(stations)) {
  if ( length(unique(stations[[i]]))==1 ) {
    uselessCols_stations <- c(uselessCols_stations, i)
  }
}

# weather
uselessCols_weather <- c()
for (i in colnames(weather)) {
  if ( length(unique(weather[[i]]))==1 ) {
    uselessCols_weather <- c(uselessCols_weather, i)
  }
}

```
Notamos que la variables "status" en la base con información de los viajes contiene un único valor presente en todas las observaciones. Lo mismo sucede con "STATION", "STATION_NAME", "ELEVATION", "LATITUDE" y "LONGITUDE" en la base con datos del clima. Se presentan los valores de las variables mencionadas para evaluar su utilidad.

```{r}

uselessCols <- c(uselessCols_trips, uselessCols_weather)
uValues <- c(unique(trips[,uselessCols_trips]), unique(weather[,uselessCols_weather]))
names(uValues) <- NULL
kable(cbind(uselessCols, uValues), 
      col.names = c("Nombre de la variable","Valor único"), align = "lr", booktabs=T) %>%
  kable_styling(position = "center", latex_options="HOLD_position")

```

FVG_comentario: Compañeros, noten cómo las lecturas del clima de weather pertenecen a una sola estación de medición ubicada en Boston, MA., mientras que las estaciones de bicicletas están no sólo en Boston, sino en Cambridge, Brookline, y Somerville como se observa en la tabla de abajo. Si queremos usar estos datos habrá que argumentar el porqué de su validez (por ejemplo, suficiente cercanía -medible a través de latitud y longitud- implica mismo clima). 

```{r}

n_obs <- c()
for (i in unique(stations$municipal)) {
  n_obs <- c(n_obs, nrow(stations[stations$municipal==i,]))
}

kable(cbind(unique(stations$municipal), n_obs), 
      col.names = c("Municipalidad","Número de estaciones"), align = "lr", booktabs=T) %>%
  kable_styling(position = "center", latex_options="HOLD_position")

```
Se presentan finalmente  algunos estadísticos relevantes sobre las variables numéricas de los viajes.

```{r}

# No muestro las variables de id de la estación y viaje, ni el año de nacimiento (debatible)
trips$start_hour <- as.numeric(trips$start_hour)
tdf <- select_if(trips, is.numeric)
tdf <- subset(tdf, select = -c(seq_id,hubway_id))
#tdf <- tdf[ ,-c(seq_id,hubway_id)]
aux <- matrix(NA, ncol = 8, nrow = 10) 
k <- 1
for (i in colnames(tdf)) {
  qu <- quantile(trips[[i]], probs = c(0.05, 0.25, 0.5, 0.75, 0.95), na.rm = TRUE) 
  n <- length(which(!is.na(trips[[i]])))
  NAs <- nrow(trips)-n
  mean <- format(round(mean(trips[[i]], na.rm = TRUE), digits = 4), scientific = FALSE) 
  min <- min(trips[[i]],na.rm = TRUE)
  max <- max(trips[[i]], na.rm = TRUE) 
  aux[k,] <- c(mean, min, qu, max) 
  k <- k + 1
}
colnames(aux) <- c("Media", "Mín.", "p05", "p25", "p50", "p75", "p95", "Máx.") 
rownames(aux) <- colnames(tdf)
kable(aux, booktabs=T) %>% kable_styling(position = "center", latex_options="HOLD_position")

```

## Análisis de redes 

```{r}

edges<-trips %>% select(strt_statn,end_statn,duration) %>% na.omit()
names(edges)<-c("from","to","weight")
nodes<-stations%>% select(id,terminal)
#edges<-sample_n(edges,1000)
edges<-edges %>% filter(from==3)
```

```{r}
routes_igraph <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)

```


```{r}

ggraph(routes_igraph, layout = "linear") + 
  geom_edge_arc(aes(width = weight), alpha = 0.8) + 
  scale_edge_width(range = c(0.2, 2)) +
  labs(edge_width = "Letters") +
  theme_graph()


```

```{r}

sankeyNetwork(Links = edges, Nodes = nodes, Source = "from", Target = "to", 
              NodeID = "terminal", Value = "weight")

```

se me ocurre un arbol /logit multinomial/ o algo con efectos fijos donde aprovechemos la esperanza del tiempo de bici dado una terminal en particual
